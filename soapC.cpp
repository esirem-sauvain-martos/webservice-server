/* soapC.cpp
   Generated by gSOAP 2.8.98 for networkManagement.hpp

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.98 2020-03-21 19:15:26 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_ns__set_interface_ip_address:
		return soap_in_ns__set_interface_ip_address(soap, tag, NULL, "ns:set-interface-ip-address");
	case SOAP_TYPE_ns__set_hostname:
		return soap_in_ns__set_hostname(soap, tag, NULL, "ns:set-hostname");
	case SOAP_TYPE_ns__get_interface_speed:
		return soap_in_ns__get_interface_speed(soap, tag, NULL, "ns:get-interface-speed");
	case SOAP_TYPE_ns__get_interface_speedResponse:
		return soap_in_ns__get_interface_speedResponse(soap, tag, NULL, "ns:get-interface-speedResponse");
	case SOAP_TYPE_ns__get_interface_ip_address:
		return soap_in_ns__get_interface_ip_address(soap, tag, NULL, "ns:get-interface-ip-address");
	case SOAP_TYPE_ns__get_interface_ip_addressResponse:
		return soap_in_ns__get_interface_ip_addressResponse(soap, tag, NULL, "ns:get-interface-ip-addressResponse");
	case SOAP_TYPE_ns__get_interface_info:
		return soap_in_ns__get_interface_info(soap, tag, NULL, "ns:get-interface-info");
	case SOAP_TYPE_ns__get_interface_infoResponse:
		return soap_in_ns__get_interface_infoResponse(soap, tag, NULL, "ns:get-interface-infoResponse");
	case SOAP_TYPE_ns__get_interface_names:
		return soap_in_ns__get_interface_names(soap, tag, NULL, "ns:get-interface-names");
	case SOAP_TYPE_ns__get_interface_namesResponse:
		return soap_in_ns__get_interface_namesResponse(soap, tag, NULL, "ns:get-interface-namesResponse");
	case SOAP_TYPE_ns__get_interface_number:
		return soap_in_ns__get_interface_number(soap, tag, NULL, "ns:get-interface-number");
	case SOAP_TYPE_ns__get_interface_numberResponse:
		return soap_in_ns__get_interface_numberResponse(soap, tag, NULL, "ns:get-interface-numberResponse");
	case SOAP_TYPE_ns__get_drive_used_capatity:
		return soap_in_ns__get_drive_used_capatity(soap, tag, NULL, "ns:get-drive-used-capatity");
	case SOAP_TYPE_ns__get_drive_used_capatityResponse:
		return soap_in_ns__get_drive_used_capatityResponse(soap, tag, NULL, "ns:get-drive-used-capatityResponse");
	case SOAP_TYPE_ns__get_drive_total_capacity:
		return soap_in_ns__get_drive_total_capacity(soap, tag, NULL, "ns:get-drive-total-capacity");
	case SOAP_TYPE_ns__get_drive_total_capacityResponse:
		return soap_in_ns__get_drive_total_capacityResponse(soap, tag, NULL, "ns:get-drive-total-capacityResponse");
	case SOAP_TYPE_ns__get_drive_info:
		return soap_in_ns__get_drive_info(soap, tag, NULL, "ns:get-drive-info");
	case SOAP_TYPE_ns__get_drive_infoResponse:
		return soap_in_ns__get_drive_infoResponse(soap, tag, NULL, "ns:get-drive-infoResponse");
	case SOAP_TYPE_ns__get_drive_names:
		return soap_in_ns__get_drive_names(soap, tag, NULL, "ns:get-drive-names");
	case SOAP_TYPE_ns__get_drive_namesResponse:
		return soap_in_ns__get_drive_namesResponse(soap, tag, NULL, "ns:get-drive-namesResponse");
	case SOAP_TYPE_ns__get_drive_number:
		return soap_in_ns__get_drive_number(soap, tag, NULL, "ns:get-drive-number");
	case SOAP_TYPE_ns__get_drive_numberResponse:
		return soap_in_ns__get_drive_numberResponse(soap, tag, NULL, "ns:get-drive-numberResponse");
	case SOAP_TYPE_ns__get_memory_free:
		return soap_in_ns__get_memory_free(soap, tag, NULL, "ns:get-memory-free");
	case SOAP_TYPE_ns__get_memory_freeResponse:
		return soap_in_ns__get_memory_freeResponse(soap, tag, NULL, "ns:get-memory-freeResponse");
	case SOAP_TYPE_ns__get_memory_available:
		return soap_in_ns__get_memory_available(soap, tag, NULL, "ns:get-memory-available");
	case SOAP_TYPE_ns__get_memory_availableResponse:
		return soap_in_ns__get_memory_availableResponse(soap, tag, NULL, "ns:get-memory-availableResponse");
	case SOAP_TYPE_ns__get_memory_info:
		return soap_in_ns__get_memory_info(soap, tag, NULL, "ns:get-memory-info");
	case SOAP_TYPE_ns__get_memory_infoResponse:
		return soap_in_ns__get_memory_infoResponse(soap, tag, NULL, "ns:get-memory-infoResponse");
	case SOAP_TYPE_ns__get_cpu_usage:
		return soap_in_ns__get_cpu_usage(soap, tag, NULL, "ns:get-cpu-usage");
	case SOAP_TYPE_ns__get_cpu_usageResponse:
		return soap_in_ns__get_cpu_usageResponse(soap, tag, NULL, "ns:get-cpu-usageResponse");
	case SOAP_TYPE_ns__get_cpu_info:
		return soap_in_ns__get_cpu_info(soap, tag, NULL, "ns:get-cpu-info");
	case SOAP_TYPE_ns__get_cpu_infoResponse:
		return soap_in_ns__get_cpu_infoResponse(soap, tag, NULL, "ns:get-cpu-infoResponse");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:set-interface-ip-address"))
		{	*type = SOAP_TYPE_ns__set_interface_ip_address;
			return soap_in_ns__set_interface_ip_address(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:set-hostname"))
		{	*type = SOAP_TYPE_ns__set_hostname;
			return soap_in_ns__set_hostname(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-speed"))
		{	*type = SOAP_TYPE_ns__get_interface_speed;
			return soap_in_ns__get_interface_speed(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-speedResponse"))
		{	*type = SOAP_TYPE_ns__get_interface_speedResponse;
			return soap_in_ns__get_interface_speedResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-ip-address"))
		{	*type = SOAP_TYPE_ns__get_interface_ip_address;
			return soap_in_ns__get_interface_ip_address(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-ip-addressResponse"))
		{	*type = SOAP_TYPE_ns__get_interface_ip_addressResponse;
			return soap_in_ns__get_interface_ip_addressResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-info"))
		{	*type = SOAP_TYPE_ns__get_interface_info;
			return soap_in_ns__get_interface_info(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-infoResponse"))
		{	*type = SOAP_TYPE_ns__get_interface_infoResponse;
			return soap_in_ns__get_interface_infoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-names"))
		{	*type = SOAP_TYPE_ns__get_interface_names;
			return soap_in_ns__get_interface_names(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-namesResponse"))
		{	*type = SOAP_TYPE_ns__get_interface_namesResponse;
			return soap_in_ns__get_interface_namesResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-number"))
		{	*type = SOAP_TYPE_ns__get_interface_number;
			return soap_in_ns__get_interface_number(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-interface-numberResponse"))
		{	*type = SOAP_TYPE_ns__get_interface_numberResponse;
			return soap_in_ns__get_interface_numberResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-used-capatity"))
		{	*type = SOAP_TYPE_ns__get_drive_used_capatity;
			return soap_in_ns__get_drive_used_capatity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-used-capatityResponse"))
		{	*type = SOAP_TYPE_ns__get_drive_used_capatityResponse;
			return soap_in_ns__get_drive_used_capatityResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-total-capacity"))
		{	*type = SOAP_TYPE_ns__get_drive_total_capacity;
			return soap_in_ns__get_drive_total_capacity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-total-capacityResponse"))
		{	*type = SOAP_TYPE_ns__get_drive_total_capacityResponse;
			return soap_in_ns__get_drive_total_capacityResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-info"))
		{	*type = SOAP_TYPE_ns__get_drive_info;
			return soap_in_ns__get_drive_info(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-infoResponse"))
		{	*type = SOAP_TYPE_ns__get_drive_infoResponse;
			return soap_in_ns__get_drive_infoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-names"))
		{	*type = SOAP_TYPE_ns__get_drive_names;
			return soap_in_ns__get_drive_names(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-namesResponse"))
		{	*type = SOAP_TYPE_ns__get_drive_namesResponse;
			return soap_in_ns__get_drive_namesResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-number"))
		{	*type = SOAP_TYPE_ns__get_drive_number;
			return soap_in_ns__get_drive_number(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-drive-numberResponse"))
		{	*type = SOAP_TYPE_ns__get_drive_numberResponse;
			return soap_in_ns__get_drive_numberResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-memory-free"))
		{	*type = SOAP_TYPE_ns__get_memory_free;
			return soap_in_ns__get_memory_free(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-memory-freeResponse"))
		{	*type = SOAP_TYPE_ns__get_memory_freeResponse;
			return soap_in_ns__get_memory_freeResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-memory-available"))
		{	*type = SOAP_TYPE_ns__get_memory_available;
			return soap_in_ns__get_memory_available(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-memory-availableResponse"))
		{	*type = SOAP_TYPE_ns__get_memory_availableResponse;
			return soap_in_ns__get_memory_availableResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-memory-info"))
		{	*type = SOAP_TYPE_ns__get_memory_info;
			return soap_in_ns__get_memory_info(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-memory-infoResponse"))
		{	*type = SOAP_TYPE_ns__get_memory_infoResponse;
			return soap_in_ns__get_memory_infoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-cpu-usage"))
		{	*type = SOAP_TYPE_ns__get_cpu_usage;
			return soap_in_ns__get_cpu_usage(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-cpu-usageResponse"))
		{	*type = SOAP_TYPE_ns__get_cpu_usageResponse;
			return soap_in_ns__get_cpu_usageResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-cpu-info"))
		{	*type = SOAP_TYPE_ns__get_cpu_info;
			return soap_in_ns__get_cpu_info(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-cpu-infoResponse"))
		{	*type = SOAP_TYPE_ns__get_cpu_infoResponse;
			return soap_in_ns__get_cpu_infoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns__set_interface_ip_address:
		return soap_out_ns__set_interface_ip_address(soap, tag, id, (const struct ns__set_interface_ip_address *)ptr, "ns:set-interface-ip-address");
	case SOAP_TYPE_ns__set_hostname:
		return soap_out_ns__set_hostname(soap, tag, id, (const struct ns__set_hostname *)ptr, "ns:set-hostname");
	case SOAP_TYPE_ns__get_interface_speed:
		return soap_out_ns__get_interface_speed(soap, tag, id, (const struct ns__get_interface_speed *)ptr, "ns:get-interface-speed");
	case SOAP_TYPE_ns__get_interface_speedResponse:
		return soap_out_ns__get_interface_speedResponse(soap, tag, id, (const struct ns__get_interface_speedResponse *)ptr, "ns:get-interface-speedResponse");
	case SOAP_TYPE_ns__get_interface_ip_address:
		return soap_out_ns__get_interface_ip_address(soap, tag, id, (const struct ns__get_interface_ip_address *)ptr, "ns:get-interface-ip-address");
	case SOAP_TYPE_ns__get_interface_ip_addressResponse:
		return soap_out_ns__get_interface_ip_addressResponse(soap, tag, id, (const struct ns__get_interface_ip_addressResponse *)ptr, "ns:get-interface-ip-addressResponse");
	case SOAP_TYPE_ns__get_interface_info:
		return soap_out_ns__get_interface_info(soap, tag, id, (const struct ns__get_interface_info *)ptr, "ns:get-interface-info");
	case SOAP_TYPE_ns__get_interface_infoResponse:
		return soap_out_ns__get_interface_infoResponse(soap, tag, id, (const struct ns__get_interface_infoResponse *)ptr, "ns:get-interface-infoResponse");
	case SOAP_TYPE_ns__get_interface_names:
		return soap_out_ns__get_interface_names(soap, tag, id, (const struct ns__get_interface_names *)ptr, "ns:get-interface-names");
	case SOAP_TYPE_ns__get_interface_namesResponse:
		return soap_out_ns__get_interface_namesResponse(soap, tag, id, (const struct ns__get_interface_namesResponse *)ptr, "ns:get-interface-namesResponse");
	case SOAP_TYPE_ns__get_interface_number:
		return soap_out_ns__get_interface_number(soap, tag, id, (const struct ns__get_interface_number *)ptr, "ns:get-interface-number");
	case SOAP_TYPE_ns__get_interface_numberResponse:
		return soap_out_ns__get_interface_numberResponse(soap, tag, id, (const struct ns__get_interface_numberResponse *)ptr, "ns:get-interface-numberResponse");
	case SOAP_TYPE_ns__get_drive_used_capatity:
		return soap_out_ns__get_drive_used_capatity(soap, tag, id, (const struct ns__get_drive_used_capatity *)ptr, "ns:get-drive-used-capatity");
	case SOAP_TYPE_ns__get_drive_used_capatityResponse:
		return soap_out_ns__get_drive_used_capatityResponse(soap, tag, id, (const struct ns__get_drive_used_capatityResponse *)ptr, "ns:get-drive-used-capatityResponse");
	case SOAP_TYPE_ns__get_drive_total_capacity:
		return soap_out_ns__get_drive_total_capacity(soap, tag, id, (const struct ns__get_drive_total_capacity *)ptr, "ns:get-drive-total-capacity");
	case SOAP_TYPE_ns__get_drive_total_capacityResponse:
		return soap_out_ns__get_drive_total_capacityResponse(soap, tag, id, (const struct ns__get_drive_total_capacityResponse *)ptr, "ns:get-drive-total-capacityResponse");
	case SOAP_TYPE_ns__get_drive_info:
		return soap_out_ns__get_drive_info(soap, tag, id, (const struct ns__get_drive_info *)ptr, "ns:get-drive-info");
	case SOAP_TYPE_ns__get_drive_infoResponse:
		return soap_out_ns__get_drive_infoResponse(soap, tag, id, (const struct ns__get_drive_infoResponse *)ptr, "ns:get-drive-infoResponse");
	case SOAP_TYPE_ns__get_drive_names:
		return soap_out_ns__get_drive_names(soap, tag, id, (const struct ns__get_drive_names *)ptr, "ns:get-drive-names");
	case SOAP_TYPE_ns__get_drive_namesResponse:
		return soap_out_ns__get_drive_namesResponse(soap, tag, id, (const struct ns__get_drive_namesResponse *)ptr, "ns:get-drive-namesResponse");
	case SOAP_TYPE_ns__get_drive_number:
		return soap_out_ns__get_drive_number(soap, tag, id, (const struct ns__get_drive_number *)ptr, "ns:get-drive-number");
	case SOAP_TYPE_ns__get_drive_numberResponse:
		return soap_out_ns__get_drive_numberResponse(soap, tag, id, (const struct ns__get_drive_numberResponse *)ptr, "ns:get-drive-numberResponse");
	case SOAP_TYPE_ns__get_memory_free:
		return soap_out_ns__get_memory_free(soap, tag, id, (const struct ns__get_memory_free *)ptr, "ns:get-memory-free");
	case SOAP_TYPE_ns__get_memory_freeResponse:
		return soap_out_ns__get_memory_freeResponse(soap, tag, id, (const struct ns__get_memory_freeResponse *)ptr, "ns:get-memory-freeResponse");
	case SOAP_TYPE_ns__get_memory_available:
		return soap_out_ns__get_memory_available(soap, tag, id, (const struct ns__get_memory_available *)ptr, "ns:get-memory-available");
	case SOAP_TYPE_ns__get_memory_availableResponse:
		return soap_out_ns__get_memory_availableResponse(soap, tag, id, (const struct ns__get_memory_availableResponse *)ptr, "ns:get-memory-availableResponse");
	case SOAP_TYPE_ns__get_memory_info:
		return soap_out_ns__get_memory_info(soap, tag, id, (const struct ns__get_memory_info *)ptr, "ns:get-memory-info");
	case SOAP_TYPE_ns__get_memory_infoResponse:
		return soap_out_ns__get_memory_infoResponse(soap, tag, id, (const struct ns__get_memory_infoResponse *)ptr, "ns:get-memory-infoResponse");
	case SOAP_TYPE_ns__get_cpu_usage:
		return soap_out_ns__get_cpu_usage(soap, tag, id, (const struct ns__get_cpu_usage *)ptr, "ns:get-cpu-usage");
	case SOAP_TYPE_ns__get_cpu_usageResponse:
		return soap_out_ns__get_cpu_usageResponse(soap, tag, id, (const struct ns__get_cpu_usageResponse *)ptr, "ns:get-cpu-usageResponse");
	case SOAP_TYPE_ns__get_cpu_info:
		return soap_out_ns__get_cpu_info(soap, tag, id, (const struct ns__get_cpu_info *)ptr, "ns:get-cpu-info");
	case SOAP_TYPE_ns__get_cpu_infoResponse:
		return soap_out_ns__get_cpu_infoResponse(soap, tag, id, (const struct ns__get_cpu_infoResponse *)ptr, "ns:get-cpu-infoResponse");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns__set_interface_ip_address:
		soap_serialize_ns__set_interface_ip_address(soap, (const struct ns__set_interface_ip_address *)ptr);
		break;
	case SOAP_TYPE_ns__set_hostname:
		soap_serialize_ns__set_hostname(soap, (const struct ns__set_hostname *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_speed:
		soap_serialize_ns__get_interface_speed(soap, (const struct ns__get_interface_speed *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_speedResponse:
		soap_serialize_ns__get_interface_speedResponse(soap, (const struct ns__get_interface_speedResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_ip_address:
		soap_serialize_ns__get_interface_ip_address(soap, (const struct ns__get_interface_ip_address *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_ip_addressResponse:
		soap_serialize_ns__get_interface_ip_addressResponse(soap, (const struct ns__get_interface_ip_addressResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_info:
		soap_serialize_ns__get_interface_info(soap, (const struct ns__get_interface_info *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_infoResponse:
		soap_serialize_ns__get_interface_infoResponse(soap, (const struct ns__get_interface_infoResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_names:
		soap_serialize_ns__get_interface_names(soap, (const struct ns__get_interface_names *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_namesResponse:
		soap_serialize_ns__get_interface_namesResponse(soap, (const struct ns__get_interface_namesResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_number:
		soap_serialize_ns__get_interface_number(soap, (const struct ns__get_interface_number *)ptr);
		break;
	case SOAP_TYPE_ns__get_interface_numberResponse:
		soap_serialize_ns__get_interface_numberResponse(soap, (const struct ns__get_interface_numberResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_used_capatity:
		soap_serialize_ns__get_drive_used_capatity(soap, (const struct ns__get_drive_used_capatity *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_used_capatityResponse:
		soap_serialize_ns__get_drive_used_capatityResponse(soap, (const struct ns__get_drive_used_capatityResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_total_capacity:
		soap_serialize_ns__get_drive_total_capacity(soap, (const struct ns__get_drive_total_capacity *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_total_capacityResponse:
		soap_serialize_ns__get_drive_total_capacityResponse(soap, (const struct ns__get_drive_total_capacityResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_info:
		soap_serialize_ns__get_drive_info(soap, (const struct ns__get_drive_info *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_infoResponse:
		soap_serialize_ns__get_drive_infoResponse(soap, (const struct ns__get_drive_infoResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_names:
		soap_serialize_ns__get_drive_names(soap, (const struct ns__get_drive_names *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_namesResponse:
		soap_serialize_ns__get_drive_namesResponse(soap, (const struct ns__get_drive_namesResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_number:
		soap_serialize_ns__get_drive_number(soap, (const struct ns__get_drive_number *)ptr);
		break;
	case SOAP_TYPE_ns__get_drive_numberResponse:
		soap_serialize_ns__get_drive_numberResponse(soap, (const struct ns__get_drive_numberResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_memory_free:
		soap_serialize_ns__get_memory_free(soap, (const struct ns__get_memory_free *)ptr);
		break;
	case SOAP_TYPE_ns__get_memory_freeResponse:
		soap_serialize_ns__get_memory_freeResponse(soap, (const struct ns__get_memory_freeResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_memory_available:
		soap_serialize_ns__get_memory_available(soap, (const struct ns__get_memory_available *)ptr);
		break;
	case SOAP_TYPE_ns__get_memory_availableResponse:
		soap_serialize_ns__get_memory_availableResponse(soap, (const struct ns__get_memory_availableResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_memory_info:
		soap_serialize_ns__get_memory_info(soap, (const struct ns__get_memory_info *)ptr);
		break;
	case SOAP_TYPE_ns__get_memory_infoResponse:
		soap_serialize_ns__get_memory_infoResponse(soap, (const struct ns__get_memory_infoResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_cpu_usage:
		soap_serialize_ns__get_cpu_usage(soap, (const struct ns__get_cpu_usage *)ptr);
		break;
	case SOAP_TYPE_ns__get_cpu_usageResponse:
		soap_serialize_ns__get_cpu_usageResponse(soap, (const struct ns__get_cpu_usageResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_cpu_info:
		soap_serialize_ns__get_cpu_info(soap, (const struct ns__get_cpu_info *)ptr);
		break;
	case SOAP_TYPE_ns__get_cpu_infoResponse:
		soap_serialize_ns__get_cpu_infoResponse(soap, (const struct ns__get_cpu_infoResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_cpu_infoResponse:
		return (void*)soap_instantiate_ns__get_cpu_infoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_cpu_info:
		return (void*)soap_instantiate_ns__get_cpu_info(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_cpu_usageResponse:
		return (void*)soap_instantiate_ns__get_cpu_usageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_cpu_usage:
		return (void*)soap_instantiate_ns__get_cpu_usage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_memory_infoResponse:
		return (void*)soap_instantiate_ns__get_memory_infoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_memory_info:
		return (void*)soap_instantiate_ns__get_memory_info(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_memory_availableResponse:
		return (void*)soap_instantiate_ns__get_memory_availableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_memory_available:
		return (void*)soap_instantiate_ns__get_memory_available(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_memory_freeResponse:
		return (void*)soap_instantiate_ns__get_memory_freeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_memory_free:
		return (void*)soap_instantiate_ns__get_memory_free(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_numberResponse:
		return (void*)soap_instantiate_ns__get_drive_numberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_number:
		return (void*)soap_instantiate_ns__get_drive_number(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_namesResponse:
		return (void*)soap_instantiate_ns__get_drive_namesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_names:
		return (void*)soap_instantiate_ns__get_drive_names(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_infoResponse:
		return (void*)soap_instantiate_ns__get_drive_infoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_info:
		return (void*)soap_instantiate_ns__get_drive_info(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_total_capacityResponse:
		return (void*)soap_instantiate_ns__get_drive_total_capacityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_total_capacity:
		return (void*)soap_instantiate_ns__get_drive_total_capacity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_used_capatityResponse:
		return (void*)soap_instantiate_ns__get_drive_used_capatityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_drive_used_capatity:
		return (void*)soap_instantiate_ns__get_drive_used_capatity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_numberResponse:
		return (void*)soap_instantiate_ns__get_interface_numberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_number:
		return (void*)soap_instantiate_ns__get_interface_number(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_namesResponse:
		return (void*)soap_instantiate_ns__get_interface_namesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_names:
		return (void*)soap_instantiate_ns__get_interface_names(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_infoResponse:
		return (void*)soap_instantiate_ns__get_interface_infoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_info:
		return (void*)soap_instantiate_ns__get_interface_info(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_ip_addressResponse:
		return (void*)soap_instantiate_ns__get_interface_ip_addressResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_ip_address:
		return (void*)soap_instantiate_ns__get_interface_ip_address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_speedResponse:
		return (void*)soap_instantiate_ns__get_interface_speedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_interface_speed:
		return (void*)soap_instantiate_ns__get_interface_speed(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__set_hostname:
		return (void*)soap_instantiate_ns__set_hostname(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__set_interface_ip_address:
		return (void*)soap_instantiate_ns__set_interface_ip_address(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns__get_cpu_infoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_cpu_infoResponse*>(p->ptr), struct ns__get_cpu_infoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_cpu_infoResponse*>(p->ptr), struct ns__get_cpu_infoResponse);
		break;
	case SOAP_TYPE_ns__get_cpu_info:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_cpu_info*>(p->ptr), struct ns__get_cpu_info);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_cpu_info*>(p->ptr), struct ns__get_cpu_info);
		break;
	case SOAP_TYPE_ns__get_cpu_usageResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_cpu_usageResponse*>(p->ptr), struct ns__get_cpu_usageResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_cpu_usageResponse*>(p->ptr), struct ns__get_cpu_usageResponse);
		break;
	case SOAP_TYPE_ns__get_cpu_usage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_cpu_usage*>(p->ptr), struct ns__get_cpu_usage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_cpu_usage*>(p->ptr), struct ns__get_cpu_usage);
		break;
	case SOAP_TYPE_ns__get_memory_infoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_memory_infoResponse*>(p->ptr), struct ns__get_memory_infoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_memory_infoResponse*>(p->ptr), struct ns__get_memory_infoResponse);
		break;
	case SOAP_TYPE_ns__get_memory_info:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_memory_info*>(p->ptr), struct ns__get_memory_info);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_memory_info*>(p->ptr), struct ns__get_memory_info);
		break;
	case SOAP_TYPE_ns__get_memory_availableResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_memory_availableResponse*>(p->ptr), struct ns__get_memory_availableResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_memory_availableResponse*>(p->ptr), struct ns__get_memory_availableResponse);
		break;
	case SOAP_TYPE_ns__get_memory_available:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_memory_available*>(p->ptr), struct ns__get_memory_available);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_memory_available*>(p->ptr), struct ns__get_memory_available);
		break;
	case SOAP_TYPE_ns__get_memory_freeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_memory_freeResponse*>(p->ptr), struct ns__get_memory_freeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_memory_freeResponse*>(p->ptr), struct ns__get_memory_freeResponse);
		break;
	case SOAP_TYPE_ns__get_memory_free:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_memory_free*>(p->ptr), struct ns__get_memory_free);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_memory_free*>(p->ptr), struct ns__get_memory_free);
		break;
	case SOAP_TYPE_ns__get_drive_numberResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_numberResponse*>(p->ptr), struct ns__get_drive_numberResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_numberResponse*>(p->ptr), struct ns__get_drive_numberResponse);
		break;
	case SOAP_TYPE_ns__get_drive_number:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_number*>(p->ptr), struct ns__get_drive_number);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_number*>(p->ptr), struct ns__get_drive_number);
		break;
	case SOAP_TYPE_ns__get_drive_namesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_namesResponse*>(p->ptr), struct ns__get_drive_namesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_namesResponse*>(p->ptr), struct ns__get_drive_namesResponse);
		break;
	case SOAP_TYPE_ns__get_drive_names:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_names*>(p->ptr), struct ns__get_drive_names);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_names*>(p->ptr), struct ns__get_drive_names);
		break;
	case SOAP_TYPE_ns__get_drive_infoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_infoResponse*>(p->ptr), struct ns__get_drive_infoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_infoResponse*>(p->ptr), struct ns__get_drive_infoResponse);
		break;
	case SOAP_TYPE_ns__get_drive_info:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_info*>(p->ptr), struct ns__get_drive_info);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_info*>(p->ptr), struct ns__get_drive_info);
		break;
	case SOAP_TYPE_ns__get_drive_total_capacityResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_total_capacityResponse*>(p->ptr), struct ns__get_drive_total_capacityResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_total_capacityResponse*>(p->ptr), struct ns__get_drive_total_capacityResponse);
		break;
	case SOAP_TYPE_ns__get_drive_total_capacity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_total_capacity*>(p->ptr), struct ns__get_drive_total_capacity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_total_capacity*>(p->ptr), struct ns__get_drive_total_capacity);
		break;
	case SOAP_TYPE_ns__get_drive_used_capatityResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_used_capatityResponse*>(p->ptr), struct ns__get_drive_used_capatityResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_used_capatityResponse*>(p->ptr), struct ns__get_drive_used_capatityResponse);
		break;
	case SOAP_TYPE_ns__get_drive_used_capatity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_drive_used_capatity*>(p->ptr), struct ns__get_drive_used_capatity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_drive_used_capatity*>(p->ptr), struct ns__get_drive_used_capatity);
		break;
	case SOAP_TYPE_ns__get_interface_numberResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_numberResponse*>(p->ptr), struct ns__get_interface_numberResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_numberResponse*>(p->ptr), struct ns__get_interface_numberResponse);
		break;
	case SOAP_TYPE_ns__get_interface_number:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_number*>(p->ptr), struct ns__get_interface_number);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_number*>(p->ptr), struct ns__get_interface_number);
		break;
	case SOAP_TYPE_ns__get_interface_namesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_namesResponse*>(p->ptr), struct ns__get_interface_namesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_namesResponse*>(p->ptr), struct ns__get_interface_namesResponse);
		break;
	case SOAP_TYPE_ns__get_interface_names:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_names*>(p->ptr), struct ns__get_interface_names);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_names*>(p->ptr), struct ns__get_interface_names);
		break;
	case SOAP_TYPE_ns__get_interface_infoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_infoResponse*>(p->ptr), struct ns__get_interface_infoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_infoResponse*>(p->ptr), struct ns__get_interface_infoResponse);
		break;
	case SOAP_TYPE_ns__get_interface_info:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_info*>(p->ptr), struct ns__get_interface_info);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_info*>(p->ptr), struct ns__get_interface_info);
		break;
	case SOAP_TYPE_ns__get_interface_ip_addressResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_ip_addressResponse*>(p->ptr), struct ns__get_interface_ip_addressResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_ip_addressResponse*>(p->ptr), struct ns__get_interface_ip_addressResponse);
		break;
	case SOAP_TYPE_ns__get_interface_ip_address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_ip_address*>(p->ptr), struct ns__get_interface_ip_address);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_ip_address*>(p->ptr), struct ns__get_interface_ip_address);
		break;
	case SOAP_TYPE_ns__get_interface_speedResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_speedResponse*>(p->ptr), struct ns__get_interface_speedResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_speedResponse*>(p->ptr), struct ns__get_interface_speedResponse);
		break;
	case SOAP_TYPE_ns__get_interface_speed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__get_interface_speed*>(p->ptr), struct ns__get_interface_speed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__get_interface_speed*>(p->ptr), struct ns__get_interface_speed);
		break;
	case SOAP_TYPE_ns__set_hostname:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__set_hostname*>(p->ptr), struct ns__set_hostname);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__set_hostname*>(p->ptr), struct ns__set_hostname);
		break;
	case SOAP_TYPE_ns__set_interface_ip_address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns__set_interface_ip_address*>(p->ptr), struct ns__set_interface_ip_address);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns__set_interface_ip_address*>(p->ptr), struct ns__set_interface_ip_address);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns__get_cpu_infoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_cpu_infoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_cpu_infoResponse*)p = *(struct ns__get_cpu_infoResponse*)q;
		break;
	case SOAP_TYPE_ns__get_cpu_info:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_cpu_info type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_cpu_info*)p = *(struct ns__get_cpu_info*)q;
		break;
	case SOAP_TYPE_ns__get_cpu_usageResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_cpu_usageResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_cpu_usageResponse*)p = *(struct ns__get_cpu_usageResponse*)q;
		break;
	case SOAP_TYPE_ns__get_cpu_usage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_cpu_usage type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_cpu_usage*)p = *(struct ns__get_cpu_usage*)q;
		break;
	case SOAP_TYPE_ns__get_memory_infoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_memory_infoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_memory_infoResponse*)p = *(struct ns__get_memory_infoResponse*)q;
		break;
	case SOAP_TYPE_ns__get_memory_info:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_memory_info type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_memory_info*)p = *(struct ns__get_memory_info*)q;
		break;
	case SOAP_TYPE_ns__get_memory_availableResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_memory_availableResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_memory_availableResponse*)p = *(struct ns__get_memory_availableResponse*)q;
		break;
	case SOAP_TYPE_ns__get_memory_available:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_memory_available type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_memory_available*)p = *(struct ns__get_memory_available*)q;
		break;
	case SOAP_TYPE_ns__get_memory_freeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_memory_freeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_memory_freeResponse*)p = *(struct ns__get_memory_freeResponse*)q;
		break;
	case SOAP_TYPE_ns__get_memory_free:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_memory_free type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_memory_free*)p = *(struct ns__get_memory_free*)q;
		break;
	case SOAP_TYPE_ns__get_drive_numberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_numberResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_numberResponse*)p = *(struct ns__get_drive_numberResponse*)q;
		break;
	case SOAP_TYPE_ns__get_drive_number:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_number type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_number*)p = *(struct ns__get_drive_number*)q;
		break;
	case SOAP_TYPE_ns__get_drive_namesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_namesResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_namesResponse*)p = *(struct ns__get_drive_namesResponse*)q;
		break;
	case SOAP_TYPE_ns__get_drive_names:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_names type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_names*)p = *(struct ns__get_drive_names*)q;
		break;
	case SOAP_TYPE_ns__get_drive_infoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_infoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_infoResponse*)p = *(struct ns__get_drive_infoResponse*)q;
		break;
	case SOAP_TYPE_ns__get_drive_info:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_info type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_info*)p = *(struct ns__get_drive_info*)q;
		break;
	case SOAP_TYPE_ns__get_drive_total_capacityResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_total_capacityResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_total_capacityResponse*)p = *(struct ns__get_drive_total_capacityResponse*)q;
		break;
	case SOAP_TYPE_ns__get_drive_total_capacity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_total_capacity type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_total_capacity*)p = *(struct ns__get_drive_total_capacity*)q;
		break;
	case SOAP_TYPE_ns__get_drive_used_capatityResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_used_capatityResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_used_capatityResponse*)p = *(struct ns__get_drive_used_capatityResponse*)q;
		break;
	case SOAP_TYPE_ns__get_drive_used_capatity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_drive_used_capatity type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_drive_used_capatity*)p = *(struct ns__get_drive_used_capatity*)q;
		break;
	case SOAP_TYPE_ns__get_interface_numberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_numberResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_numberResponse*)p = *(struct ns__get_interface_numberResponse*)q;
		break;
	case SOAP_TYPE_ns__get_interface_number:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_number type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_number*)p = *(struct ns__get_interface_number*)q;
		break;
	case SOAP_TYPE_ns__get_interface_namesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_namesResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_namesResponse*)p = *(struct ns__get_interface_namesResponse*)q;
		break;
	case SOAP_TYPE_ns__get_interface_names:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_names type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_names*)p = *(struct ns__get_interface_names*)q;
		break;
	case SOAP_TYPE_ns__get_interface_infoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_infoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_infoResponse*)p = *(struct ns__get_interface_infoResponse*)q;
		break;
	case SOAP_TYPE_ns__get_interface_info:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_info type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_info*)p = *(struct ns__get_interface_info*)q;
		break;
	case SOAP_TYPE_ns__get_interface_ip_addressResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_ip_addressResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_ip_addressResponse*)p = *(struct ns__get_interface_ip_addressResponse*)q;
		break;
	case SOAP_TYPE_ns__get_interface_ip_address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_ip_address type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_ip_address*)p = *(struct ns__get_interface_ip_address*)q;
		break;
	case SOAP_TYPE_ns__get_interface_speedResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_speedResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_speedResponse*)p = *(struct ns__get_interface_speedResponse*)q;
		break;
	case SOAP_TYPE_ns__get_interface_speed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__get_interface_speed type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__get_interface_speed*)p = *(struct ns__get_interface_speed*)q;
		break;
	case SOAP_TYPE_ns__set_hostname:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__set_hostname type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__set_hostname*)p = *(struct ns__set_hostname*)q;
		break;
	case SOAP_TYPE_ns__set_interface_ip_address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__set_interface_ip_address type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__set_interface_ip_address*)p = *(struct ns__set_interface_ip_address*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__set_interface_ip_address(struct soap *soap, struct ns__set_interface_ip_address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
	soap_default_std__string(soap, &a->ip_address);
	soap_default_std__string(soap, &a->subnet_mask);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__set_interface_ip_address(struct soap *soap, const struct ns__set_interface_ip_address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->name);
	soap_embedded(soap, &a->ip_address, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->ip_address);
	soap_embedded(soap, &a->subnet_mask, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->subnet_mask);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__set_interface_ip_address(struct soap *soap, const char *tag, int id, const struct ns__set_interface_ip_address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__set_interface_ip_address), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ip-address", -1, &a->ip_address, ""))
		return soap->error;
	if (soap_out_std__string(soap, "subnet-mask", -1, &a->subnet_mask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__set_interface_ip_address * SOAP_FMAC4 soap_in_ns__set_interface_ip_address(struct soap *soap, const char *tag, struct ns__set_interface_ip_address *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_ip_address = 1;
	size_t soap_flag_subnet_mask = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__set_interface_ip_address*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__set_interface_ip_address, sizeof(struct ns__set_interface_ip_address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__set_interface_ip_address(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			}
			if (soap_flag_ip_address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ip-address", &a->ip_address, "xsd:string"))
				{	soap_flag_ip_address--;
					continue;
				}
			}
			if (soap_flag_subnet_mask && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "subnet-mask", &a->subnet_mask, "xsd:string"))
				{	soap_flag_subnet_mask--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_ip_address > 0 || soap_flag_subnet_mask > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__set_interface_ip_address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__set_interface_ip_address, SOAP_TYPE_ns__set_interface_ip_address, sizeof(struct ns__set_interface_ip_address), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__set_interface_ip_address * SOAP_FMAC2 soap_instantiate_ns__set_interface_ip_address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__set_interface_ip_address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__set_interface_ip_address *p;
	size_t k = sizeof(struct ns__set_interface_ip_address);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__set_interface_ip_address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__set_interface_ip_address);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__set_interface_ip_address, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__set_interface_ip_address location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__set_interface_ip_address(struct soap *soap, const struct ns__set_interface_ip_address *a, const char *tag, const char *type)
{
	if (soap_out_ns__set_interface_ip_address(soap, tag ? tag : "ns:set-interface-ip-address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__set_interface_ip_address * SOAP_FMAC4 soap_get_ns__set_interface_ip_address(struct soap *soap, struct ns__set_interface_ip_address *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__set_interface_ip_address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__set_hostname(struct soap *soap, struct ns__set_hostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->hostname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__set_hostname(struct soap *soap, const struct ns__set_hostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->hostname, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->hostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__set_hostname(struct soap *soap, const char *tag, int id, const struct ns__set_hostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__set_hostname), type))
		return soap->error;
	if (soap_out_std__string(soap, "hostname", -1, &a->hostname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__set_hostname * SOAP_FMAC4 soap_in_ns__set_hostname(struct soap *soap, const char *tag, struct ns__set_hostname *a, const char *type)
{
	size_t soap_flag_hostname = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__set_hostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__set_hostname, sizeof(struct ns__set_hostname), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__set_hostname(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hostname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "hostname", &a->hostname, "xsd:string"))
				{	soap_flag_hostname--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hostname > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__set_hostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__set_hostname, SOAP_TYPE_ns__set_hostname, sizeof(struct ns__set_hostname), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__set_hostname * SOAP_FMAC2 soap_instantiate_ns__set_hostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__set_hostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__set_hostname *p;
	size_t k = sizeof(struct ns__set_hostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__set_hostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__set_hostname);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__set_hostname, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__set_hostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__set_hostname(struct soap *soap, const struct ns__set_hostname *a, const char *tag, const char *type)
{
	if (soap_out_ns__set_hostname(soap, tag ? tag : "ns:set-hostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__set_hostname * SOAP_FMAC4 soap_get_ns__set_hostname(struct soap *soap, struct ns__set_hostname *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__set_hostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_speed(struct soap *soap, struct ns__get_interface_speed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_speed(struct soap *soap, const struct ns__get_interface_speed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_speed(struct soap *soap, const char *tag, int id, const struct ns__get_interface_speed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_speed), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_speed * SOAP_FMAC4 soap_in_ns__get_interface_speed(struct soap *soap, const char *tag, struct ns__get_interface_speed *a, const char *type)
{
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_speed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_speed, sizeof(struct ns__get_interface_speed), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_speed(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_interface_speed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_speed, SOAP_TYPE_ns__get_interface_speed, sizeof(struct ns__get_interface_speed), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_speed * SOAP_FMAC2 soap_instantiate_ns__get_interface_speed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_speed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_speed *p;
	size_t k = sizeof(struct ns__get_interface_speed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_speed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_speed);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_speed, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_speed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_speed(struct soap *soap, const struct ns__get_interface_speed *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_speed(soap, tag ? tag : "ns:get-interface-speed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_speed * SOAP_FMAC4 soap_get_ns__get_interface_speed(struct soap *soap, struct ns__get_interface_speed *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_speed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_speedResponse(struct soap *soap, struct ns__get_interface_speedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->speed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_speedResponse(struct soap *soap, const struct ns__get_interface_speedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_speedResponse(struct soap *soap, const char *tag, int id, const struct ns__get_interface_speedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_speedResponse), type))
		return soap->error;
	if (soap_out_int(soap, "speed", -1, &a->speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_speedResponse * SOAP_FMAC4 soap_in_ns__get_interface_speedResponse(struct soap *soap, const char *tag, struct ns__get_interface_speedResponse *a, const char *type)
{
	size_t soap_flag_speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_speedResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_speedResponse, sizeof(struct ns__get_interface_speedResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_speedResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "speed", &a->speed, "xsd:int"))
				{	soap_flag_speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_speed > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_interface_speedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_speedResponse, SOAP_TYPE_ns__get_interface_speedResponse, sizeof(struct ns__get_interface_speedResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_speedResponse * SOAP_FMAC2 soap_instantiate_ns__get_interface_speedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_speedResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_speedResponse *p;
	size_t k = sizeof(struct ns__get_interface_speedResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_speedResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_speedResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_speedResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_speedResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_speedResponse(struct soap *soap, const struct ns__get_interface_speedResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_speedResponse(soap, tag ? tag : "ns:get-interface-speedResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_speedResponse * SOAP_FMAC4 soap_get_ns__get_interface_speedResponse(struct soap *soap, struct ns__get_interface_speedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_speedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_ip_address(struct soap *soap, struct ns__get_interface_ip_address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_ip_address(struct soap *soap, const struct ns__get_interface_ip_address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_ip_address(struct soap *soap, const char *tag, int id, const struct ns__get_interface_ip_address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_ip_address), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_ip_address * SOAP_FMAC4 soap_in_ns__get_interface_ip_address(struct soap *soap, const char *tag, struct ns__get_interface_ip_address *a, const char *type)
{
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_ip_address*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_ip_address, sizeof(struct ns__get_interface_ip_address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_ip_address(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_interface_ip_address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_ip_address, SOAP_TYPE_ns__get_interface_ip_address, sizeof(struct ns__get_interface_ip_address), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_ip_address * SOAP_FMAC2 soap_instantiate_ns__get_interface_ip_address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_ip_address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_ip_address *p;
	size_t k = sizeof(struct ns__get_interface_ip_address);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_ip_address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_ip_address);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_ip_address, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_ip_address location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_ip_address(struct soap *soap, const struct ns__get_interface_ip_address *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_ip_address(soap, tag ? tag : "ns:get-interface-ip-address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_ip_address * SOAP_FMAC4 soap_get_ns__get_interface_ip_address(struct soap *soap, struct ns__get_interface_ip_address *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_ip_address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_ip_addressResponse(struct soap *soap, struct ns__get_interface_ip_addressResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->ip_address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_ip_addressResponse(struct soap *soap, const struct ns__get_interface_ip_addressResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->ip_address, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->ip_address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_ip_addressResponse(struct soap *soap, const char *tag, int id, const struct ns__get_interface_ip_addressResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_ip_addressResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "ip-address", -1, &a->ip_address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_ip_addressResponse * SOAP_FMAC4 soap_in_ns__get_interface_ip_addressResponse(struct soap *soap, const char *tag, struct ns__get_interface_ip_addressResponse *a, const char *type)
{
	size_t soap_flag_ip_address = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_ip_addressResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_ip_addressResponse, sizeof(struct ns__get_interface_ip_addressResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_ip_addressResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ip_address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ip-address", &a->ip_address, "xsd:string"))
				{	soap_flag_ip_address--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ip_address > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_interface_ip_addressResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_ip_addressResponse, SOAP_TYPE_ns__get_interface_ip_addressResponse, sizeof(struct ns__get_interface_ip_addressResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_ip_addressResponse * SOAP_FMAC2 soap_instantiate_ns__get_interface_ip_addressResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_ip_addressResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_ip_addressResponse *p;
	size_t k = sizeof(struct ns__get_interface_ip_addressResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_ip_addressResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_ip_addressResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_ip_addressResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_ip_addressResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_ip_addressResponse(struct soap *soap, const struct ns__get_interface_ip_addressResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_ip_addressResponse(soap, tag ? tag : "ns:get-interface-ip-addressResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_ip_addressResponse * SOAP_FMAC4 soap_get_ns__get_interface_ip_addressResponse(struct soap *soap, struct ns__get_interface_ip_addressResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_ip_addressResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_info(struct soap *soap, struct ns__get_interface_info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_info(struct soap *soap, const struct ns__get_interface_info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_info(struct soap *soap, const char *tag, int id, const struct ns__get_interface_info *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_info), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_info * SOAP_FMAC4 soap_in_ns__get_interface_info(struct soap *soap, const char *tag, struct ns__get_interface_info *a, const char *type)
{
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_info*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_info, sizeof(struct ns__get_interface_info), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_info(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_interface_info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_info, SOAP_TYPE_ns__get_interface_info, sizeof(struct ns__get_interface_info), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_info * SOAP_FMAC2 soap_instantiate_ns__get_interface_info(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_info(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_info *p;
	size_t k = sizeof(struct ns__get_interface_info);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_info, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_info);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_info, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_info location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_info(struct soap *soap, const struct ns__get_interface_info *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_info(soap, tag ? tag : "ns:get-interface-info", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_info * SOAP_FMAC4 soap_get_ns__get_interface_info(struct soap *soap, struct ns__get_interface_info *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_infoResponse(struct soap *soap, struct ns__get_interface_infoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->info);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_infoResponse(struct soap *soap, const struct ns__get_interface_infoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->info, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->info);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_infoResponse(struct soap *soap, const char *tag, int id, const struct ns__get_interface_infoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_infoResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "info", -1, &a->info, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_infoResponse * SOAP_FMAC4 soap_in_ns__get_interface_infoResponse(struct soap *soap, const char *tag, struct ns__get_interface_infoResponse *a, const char *type)
{
	size_t soap_flag_info = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_infoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_infoResponse, sizeof(struct ns__get_interface_infoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_infoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "info", &a->info, "xsd:string"))
				{	soap_flag_info--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_info > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_interface_infoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_infoResponse, SOAP_TYPE_ns__get_interface_infoResponse, sizeof(struct ns__get_interface_infoResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_infoResponse * SOAP_FMAC2 soap_instantiate_ns__get_interface_infoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_infoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_infoResponse *p;
	size_t k = sizeof(struct ns__get_interface_infoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_infoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_infoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_infoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_infoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_infoResponse(struct soap *soap, const struct ns__get_interface_infoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_infoResponse(soap, tag ? tag : "ns:get-interface-infoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_infoResponse * SOAP_FMAC4 soap_get_ns__get_interface_infoResponse(struct soap *soap, struct ns__get_interface_infoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_infoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_names(struct soap *soap, struct ns__get_interface_names *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_names(struct soap *soap, const struct ns__get_interface_names *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_names(struct soap *soap, const char *tag, int id, const struct ns__get_interface_names *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_names), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_names * SOAP_FMAC4 soap_in_ns__get_interface_names(struct soap *soap, const char *tag, struct ns__get_interface_names *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_names*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_names, sizeof(struct ns__get_interface_names), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_names(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_interface_names *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_names, SOAP_TYPE_ns__get_interface_names, sizeof(struct ns__get_interface_names), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_names * SOAP_FMAC2 soap_instantiate_ns__get_interface_names(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_names(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_names *p;
	size_t k = sizeof(struct ns__get_interface_names);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_names, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_names);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_names, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_names location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_names(struct soap *soap, const struct ns__get_interface_names *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_names(soap, tag ? tag : "ns:get-interface-names", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_names * SOAP_FMAC4 soap_get_ns__get_interface_names(struct soap *soap, struct ns__get_interface_names *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_names(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_namesResponse(struct soap *soap, struct ns__get_interface_namesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->names = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_namesResponse(struct soap *soap, const struct ns__get_interface_namesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &a->names);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_namesResponse(struct soap *soap, const char *tag, int id, const struct ns__get_interface_namesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_namesResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "names", -1, &a->names, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_namesResponse * SOAP_FMAC4 soap_in_ns__get_interface_namesResponse(struct soap *soap, const char *tag, struct ns__get_interface_namesResponse *a, const char *type)
{
	size_t soap_flag_names = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_namesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_namesResponse, sizeof(struct ns__get_interface_namesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_namesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_names && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "names", &a->names, "xsd:string"))
				{	soap_flag_names--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_interface_namesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_namesResponse, SOAP_TYPE_ns__get_interface_namesResponse, sizeof(struct ns__get_interface_namesResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_namesResponse * SOAP_FMAC2 soap_instantiate_ns__get_interface_namesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_namesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_namesResponse *p;
	size_t k = sizeof(struct ns__get_interface_namesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_namesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_namesResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_namesResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_namesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_namesResponse(struct soap *soap, const struct ns__get_interface_namesResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_namesResponse(soap, tag ? tag : "ns:get-interface-namesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_namesResponse * SOAP_FMAC4 soap_get_ns__get_interface_namesResponse(struct soap *soap, struct ns__get_interface_namesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_namesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_number(struct soap *soap, struct ns__get_interface_number *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_number(struct soap *soap, const struct ns__get_interface_number *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_number(struct soap *soap, const char *tag, int id, const struct ns__get_interface_number *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_number), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_number * SOAP_FMAC4 soap_in_ns__get_interface_number(struct soap *soap, const char *tag, struct ns__get_interface_number *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_number*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_number, sizeof(struct ns__get_interface_number), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_number(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_interface_number *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_number, SOAP_TYPE_ns__get_interface_number, sizeof(struct ns__get_interface_number), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_number * SOAP_FMAC2 soap_instantiate_ns__get_interface_number(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_number(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_number *p;
	size_t k = sizeof(struct ns__get_interface_number);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_number, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_number);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_number, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_number location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_number(struct soap *soap, const struct ns__get_interface_number *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_number(soap, tag ? tag : "ns:get-interface-number", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_number * SOAP_FMAC4 soap_get_ns__get_interface_number(struct soap *soap, struct ns__get_interface_number *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_number(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_interface_numberResponse(struct soap *soap, struct ns__get_interface_numberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->number);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_interface_numberResponse(struct soap *soap, const struct ns__get_interface_numberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_interface_numberResponse(struct soap *soap, const char *tag, int id, const struct ns__get_interface_numberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_interface_numberResponse), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "number", -1, &a->number, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_interface_numberResponse * SOAP_FMAC4 soap_in_ns__get_interface_numberResponse(struct soap *soap, const char *tag, struct ns__get_interface_numberResponse *a, const char *type)
{
	size_t soap_flag_number = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_interface_numberResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_interface_numberResponse, sizeof(struct ns__get_interface_numberResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_interface_numberResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_number && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "number", &a->number, "xsd:unsignedInt"))
				{	soap_flag_number--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_number > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_interface_numberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_interface_numberResponse, SOAP_TYPE_ns__get_interface_numberResponse, sizeof(struct ns__get_interface_numberResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_interface_numberResponse * SOAP_FMAC2 soap_instantiate_ns__get_interface_numberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_interface_numberResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_interface_numberResponse *p;
	size_t k = sizeof(struct ns__get_interface_numberResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_interface_numberResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_interface_numberResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_interface_numberResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_interface_numberResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_interface_numberResponse(struct soap *soap, const struct ns__get_interface_numberResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_interface_numberResponse(soap, tag ? tag : "ns:get-interface-numberResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_interface_numberResponse * SOAP_FMAC4 soap_get_ns__get_interface_numberResponse(struct soap *soap, struct ns__get_interface_numberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_interface_numberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_used_capatity(struct soap *soap, struct ns__get_drive_used_capatity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_used_capatity(struct soap *soap, const struct ns__get_drive_used_capatity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_used_capatity(struct soap *soap, const char *tag, int id, const struct ns__get_drive_used_capatity *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_used_capatity), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_used_capatity * SOAP_FMAC4 soap_in_ns__get_drive_used_capatity(struct soap *soap, const char *tag, struct ns__get_drive_used_capatity *a, const char *type)
{
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_used_capatity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_used_capatity, sizeof(struct ns__get_drive_used_capatity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_used_capatity(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_drive_used_capatity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_used_capatity, SOAP_TYPE_ns__get_drive_used_capatity, sizeof(struct ns__get_drive_used_capatity), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_used_capatity * SOAP_FMAC2 soap_instantiate_ns__get_drive_used_capatity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_used_capatity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_used_capatity *p;
	size_t k = sizeof(struct ns__get_drive_used_capatity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_used_capatity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_used_capatity);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_used_capatity, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_used_capatity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_used_capatity(struct soap *soap, const struct ns__get_drive_used_capatity *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_used_capatity(soap, tag ? tag : "ns:get-drive-used-capatity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_used_capatity * SOAP_FMAC4 soap_get_ns__get_drive_used_capatity(struct soap *soap, struct ns__get_drive_used_capatity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_used_capatity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_used_capatityResponse(struct soap *soap, struct ns__get_drive_used_capatityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_used_capatityResponse(struct soap *soap, const struct ns__get_drive_used_capatityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_used_capatityResponse(struct soap *soap, const char *tag, int id, const struct ns__get_drive_used_capatityResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_used_capatityResponse), type))
		return soap->error;
	if (soap_out_float(soap, "usage", -1, &a->usage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_used_capatityResponse * SOAP_FMAC4 soap_in_ns__get_drive_used_capatityResponse(struct soap *soap, const char *tag, struct ns__get_drive_used_capatityResponse *a, const char *type)
{
	size_t soap_flag_usage = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_used_capatityResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_used_capatityResponse, sizeof(struct ns__get_drive_used_capatityResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_used_capatityResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_usage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "usage", &a->usage, "xsd:float"))
				{	soap_flag_usage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_usage > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_drive_used_capatityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_used_capatityResponse, SOAP_TYPE_ns__get_drive_used_capatityResponse, sizeof(struct ns__get_drive_used_capatityResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_used_capatityResponse * SOAP_FMAC2 soap_instantiate_ns__get_drive_used_capatityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_used_capatityResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_used_capatityResponse *p;
	size_t k = sizeof(struct ns__get_drive_used_capatityResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_used_capatityResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_used_capatityResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_used_capatityResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_used_capatityResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_used_capatityResponse(struct soap *soap, const struct ns__get_drive_used_capatityResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_used_capatityResponse(soap, tag ? tag : "ns:get-drive-used-capatityResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_used_capatityResponse * SOAP_FMAC4 soap_get_ns__get_drive_used_capatityResponse(struct soap *soap, struct ns__get_drive_used_capatityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_used_capatityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_total_capacity(struct soap *soap, struct ns__get_drive_total_capacity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_total_capacity(struct soap *soap, const struct ns__get_drive_total_capacity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_total_capacity(struct soap *soap, const char *tag, int id, const struct ns__get_drive_total_capacity *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_total_capacity), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_total_capacity * SOAP_FMAC4 soap_in_ns__get_drive_total_capacity(struct soap *soap, const char *tag, struct ns__get_drive_total_capacity *a, const char *type)
{
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_total_capacity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_total_capacity, sizeof(struct ns__get_drive_total_capacity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_total_capacity(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_drive_total_capacity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_total_capacity, SOAP_TYPE_ns__get_drive_total_capacity, sizeof(struct ns__get_drive_total_capacity), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_total_capacity * SOAP_FMAC2 soap_instantiate_ns__get_drive_total_capacity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_total_capacity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_total_capacity *p;
	size_t k = sizeof(struct ns__get_drive_total_capacity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_total_capacity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_total_capacity);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_total_capacity, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_total_capacity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_total_capacity(struct soap *soap, const struct ns__get_drive_total_capacity *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_total_capacity(soap, tag ? tag : "ns:get-drive-total-capacity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_total_capacity * SOAP_FMAC4 soap_get_ns__get_drive_total_capacity(struct soap *soap, struct ns__get_drive_total_capacity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_total_capacity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_total_capacityResponse(struct soap *soap, struct ns__get_drive_total_capacityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->total);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_total_capacityResponse(struct soap *soap, const struct ns__get_drive_total_capacityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_total_capacityResponse(struct soap *soap, const char *tag, int id, const struct ns__get_drive_total_capacityResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_total_capacityResponse), type))
		return soap->error;
	if (soap_out_float(soap, "total", -1, &a->total, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_total_capacityResponse * SOAP_FMAC4 soap_in_ns__get_drive_total_capacityResponse(struct soap *soap, const char *tag, struct ns__get_drive_total_capacityResponse *a, const char *type)
{
	size_t soap_flag_total = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_total_capacityResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_total_capacityResponse, sizeof(struct ns__get_drive_total_capacityResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_total_capacityResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "total", &a->total, "xsd:float"))
				{	soap_flag_total--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_drive_total_capacityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_total_capacityResponse, SOAP_TYPE_ns__get_drive_total_capacityResponse, sizeof(struct ns__get_drive_total_capacityResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_total_capacityResponse * SOAP_FMAC2 soap_instantiate_ns__get_drive_total_capacityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_total_capacityResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_total_capacityResponse *p;
	size_t k = sizeof(struct ns__get_drive_total_capacityResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_total_capacityResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_total_capacityResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_total_capacityResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_total_capacityResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_total_capacityResponse(struct soap *soap, const struct ns__get_drive_total_capacityResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_total_capacityResponse(soap, tag ? tag : "ns:get-drive-total-capacityResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_total_capacityResponse * SOAP_FMAC4 soap_get_ns__get_drive_total_capacityResponse(struct soap *soap, struct ns__get_drive_total_capacityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_total_capacityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_info(struct soap *soap, struct ns__get_drive_info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_info(struct soap *soap, const struct ns__get_drive_info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_info(struct soap *soap, const char *tag, int id, const struct ns__get_drive_info *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_info), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_info * SOAP_FMAC4 soap_in_ns__get_drive_info(struct soap *soap, const char *tag, struct ns__get_drive_info *a, const char *type)
{
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_info*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_info, sizeof(struct ns__get_drive_info), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_info(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_drive_info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_info, SOAP_TYPE_ns__get_drive_info, sizeof(struct ns__get_drive_info), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_info * SOAP_FMAC2 soap_instantiate_ns__get_drive_info(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_info(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_info *p;
	size_t k = sizeof(struct ns__get_drive_info);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_info, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_info);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_info, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_info location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_info(struct soap *soap, const struct ns__get_drive_info *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_info(soap, tag ? tag : "ns:get-drive-info", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_info * SOAP_FMAC4 soap_get_ns__get_drive_info(struct soap *soap, struct ns__get_drive_info *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_infoResponse(struct soap *soap, struct ns__get_drive_infoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->info);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_infoResponse(struct soap *soap, const struct ns__get_drive_infoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->info, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->info);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_infoResponse(struct soap *soap, const char *tag, int id, const struct ns__get_drive_infoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_infoResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "info", -1, &a->info, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_infoResponse * SOAP_FMAC4 soap_in_ns__get_drive_infoResponse(struct soap *soap, const char *tag, struct ns__get_drive_infoResponse *a, const char *type)
{
	size_t soap_flag_info = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_infoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_infoResponse, sizeof(struct ns__get_drive_infoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_infoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "info", &a->info, "xsd:string"))
				{	soap_flag_info--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_info > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_drive_infoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_infoResponse, SOAP_TYPE_ns__get_drive_infoResponse, sizeof(struct ns__get_drive_infoResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_infoResponse * SOAP_FMAC2 soap_instantiate_ns__get_drive_infoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_infoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_infoResponse *p;
	size_t k = sizeof(struct ns__get_drive_infoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_infoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_infoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_infoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_infoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_infoResponse(struct soap *soap, const struct ns__get_drive_infoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_infoResponse(soap, tag ? tag : "ns:get-drive-infoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_infoResponse * SOAP_FMAC4 soap_get_ns__get_drive_infoResponse(struct soap *soap, struct ns__get_drive_infoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_infoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_names(struct soap *soap, struct ns__get_drive_names *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_names(struct soap *soap, const struct ns__get_drive_names *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_names(struct soap *soap, const char *tag, int id, const struct ns__get_drive_names *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_names), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_names * SOAP_FMAC4 soap_in_ns__get_drive_names(struct soap *soap, const char *tag, struct ns__get_drive_names *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_names*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_names, sizeof(struct ns__get_drive_names), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_names(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_drive_names *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_names, SOAP_TYPE_ns__get_drive_names, sizeof(struct ns__get_drive_names), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_names * SOAP_FMAC2 soap_instantiate_ns__get_drive_names(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_names(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_names *p;
	size_t k = sizeof(struct ns__get_drive_names);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_names, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_names);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_names, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_names location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_names(struct soap *soap, const struct ns__get_drive_names *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_names(soap, tag ? tag : "ns:get-drive-names", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_names * SOAP_FMAC4 soap_get_ns__get_drive_names(struct soap *soap, struct ns__get_drive_names *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_names(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_namesResponse(struct soap *soap, struct ns__get_drive_namesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->names = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_namesResponse(struct soap *soap, const struct ns__get_drive_namesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &a->names);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_namesResponse(struct soap *soap, const char *tag, int id, const struct ns__get_drive_namesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_namesResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "names", -1, &a->names, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_namesResponse * SOAP_FMAC4 soap_in_ns__get_drive_namesResponse(struct soap *soap, const char *tag, struct ns__get_drive_namesResponse *a, const char *type)
{
	size_t soap_flag_names = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_namesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_namesResponse, sizeof(struct ns__get_drive_namesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_namesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_names && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "names", &a->names, "xsd:string"))
				{	soap_flag_names--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_drive_namesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_namesResponse, SOAP_TYPE_ns__get_drive_namesResponse, sizeof(struct ns__get_drive_namesResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_namesResponse * SOAP_FMAC2 soap_instantiate_ns__get_drive_namesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_namesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_namesResponse *p;
	size_t k = sizeof(struct ns__get_drive_namesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_namesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_namesResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_namesResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_namesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_namesResponse(struct soap *soap, const struct ns__get_drive_namesResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_namesResponse(soap, tag ? tag : "ns:get-drive-namesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_namesResponse * SOAP_FMAC4 soap_get_ns__get_drive_namesResponse(struct soap *soap, struct ns__get_drive_namesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_namesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_number(struct soap *soap, struct ns__get_drive_number *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_number(struct soap *soap, const struct ns__get_drive_number *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_number(struct soap *soap, const char *tag, int id, const struct ns__get_drive_number *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_number), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_number * SOAP_FMAC4 soap_in_ns__get_drive_number(struct soap *soap, const char *tag, struct ns__get_drive_number *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_number*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_number, sizeof(struct ns__get_drive_number), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_number(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_drive_number *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_number, SOAP_TYPE_ns__get_drive_number, sizeof(struct ns__get_drive_number), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_number * SOAP_FMAC2 soap_instantiate_ns__get_drive_number(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_number(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_number *p;
	size_t k = sizeof(struct ns__get_drive_number);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_number, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_number);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_number, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_number location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_number(struct soap *soap, const struct ns__get_drive_number *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_number(soap, tag ? tag : "ns:get-drive-number", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_number * SOAP_FMAC4 soap_get_ns__get_drive_number(struct soap *soap, struct ns__get_drive_number *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_number(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_drive_numberResponse(struct soap *soap, struct ns__get_drive_numberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->number);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_drive_numberResponse(struct soap *soap, const struct ns__get_drive_numberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_drive_numberResponse(struct soap *soap, const char *tag, int id, const struct ns__get_drive_numberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_drive_numberResponse), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "number", -1, &a->number, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_drive_numberResponse * SOAP_FMAC4 soap_in_ns__get_drive_numberResponse(struct soap *soap, const char *tag, struct ns__get_drive_numberResponse *a, const char *type)
{
	size_t soap_flag_number = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_drive_numberResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_drive_numberResponse, sizeof(struct ns__get_drive_numberResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_drive_numberResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_number && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "number", &a->number, "xsd:unsignedInt"))
				{	soap_flag_number--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_number > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_drive_numberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_drive_numberResponse, SOAP_TYPE_ns__get_drive_numberResponse, sizeof(struct ns__get_drive_numberResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_drive_numberResponse * SOAP_FMAC2 soap_instantiate_ns__get_drive_numberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_drive_numberResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_drive_numberResponse *p;
	size_t k = sizeof(struct ns__get_drive_numberResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_drive_numberResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_drive_numberResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_drive_numberResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_drive_numberResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_drive_numberResponse(struct soap *soap, const struct ns__get_drive_numberResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_drive_numberResponse(soap, tag ? tag : "ns:get-drive-numberResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_drive_numberResponse * SOAP_FMAC4 soap_get_ns__get_drive_numberResponse(struct soap *soap, struct ns__get_drive_numberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_drive_numberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_memory_free(struct soap *soap, struct ns__get_memory_free *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_memory_free(struct soap *soap, const struct ns__get_memory_free *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_memory_free(struct soap *soap, const char *tag, int id, const struct ns__get_memory_free *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_memory_free), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_memory_free * SOAP_FMAC4 soap_in_ns__get_memory_free(struct soap *soap, const char *tag, struct ns__get_memory_free *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_memory_free*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_memory_free, sizeof(struct ns__get_memory_free), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_memory_free(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_memory_free *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_memory_free, SOAP_TYPE_ns__get_memory_free, sizeof(struct ns__get_memory_free), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_memory_free * SOAP_FMAC2 soap_instantiate_ns__get_memory_free(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_memory_free(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_memory_free *p;
	size_t k = sizeof(struct ns__get_memory_free);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_memory_free, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_memory_free);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_memory_free, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_memory_free location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_memory_free(struct soap *soap, const struct ns__get_memory_free *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_memory_free(soap, tag ? tag : "ns:get-memory-free", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_memory_free * SOAP_FMAC4 soap_get_ns__get_memory_free(struct soap *soap, struct ns__get_memory_free *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_memory_free(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_memory_freeResponse(struct soap *soap, struct ns__get_memory_freeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->free);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_memory_freeResponse(struct soap *soap, const struct ns__get_memory_freeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_memory_freeResponse(struct soap *soap, const char *tag, int id, const struct ns__get_memory_freeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_memory_freeResponse), type))
		return soap->error;
	if (soap_out_float(soap, "free", -1, &a->free, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_memory_freeResponse * SOAP_FMAC4 soap_in_ns__get_memory_freeResponse(struct soap *soap, const char *tag, struct ns__get_memory_freeResponse *a, const char *type)
{
	size_t soap_flag_free = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_memory_freeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_memory_freeResponse, sizeof(struct ns__get_memory_freeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_memory_freeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_free && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "free", &a->free, "xsd:float"))
				{	soap_flag_free--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_free > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_memory_freeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_memory_freeResponse, SOAP_TYPE_ns__get_memory_freeResponse, sizeof(struct ns__get_memory_freeResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_memory_freeResponse * SOAP_FMAC2 soap_instantiate_ns__get_memory_freeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_memory_freeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_memory_freeResponse *p;
	size_t k = sizeof(struct ns__get_memory_freeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_memory_freeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_memory_freeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_memory_freeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_memory_freeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_memory_freeResponse(struct soap *soap, const struct ns__get_memory_freeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_memory_freeResponse(soap, tag ? tag : "ns:get-memory-freeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_memory_freeResponse * SOAP_FMAC4 soap_get_ns__get_memory_freeResponse(struct soap *soap, struct ns__get_memory_freeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_memory_freeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_memory_available(struct soap *soap, struct ns__get_memory_available *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_memory_available(struct soap *soap, const struct ns__get_memory_available *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_memory_available(struct soap *soap, const char *tag, int id, const struct ns__get_memory_available *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_memory_available), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_memory_available * SOAP_FMAC4 soap_in_ns__get_memory_available(struct soap *soap, const char *tag, struct ns__get_memory_available *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_memory_available*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_memory_available, sizeof(struct ns__get_memory_available), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_memory_available(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_memory_available *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_memory_available, SOAP_TYPE_ns__get_memory_available, sizeof(struct ns__get_memory_available), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_memory_available * SOAP_FMAC2 soap_instantiate_ns__get_memory_available(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_memory_available(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_memory_available *p;
	size_t k = sizeof(struct ns__get_memory_available);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_memory_available, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_memory_available);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_memory_available, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_memory_available location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_memory_available(struct soap *soap, const struct ns__get_memory_available *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_memory_available(soap, tag ? tag : "ns:get-memory-available", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_memory_available * SOAP_FMAC4 soap_get_ns__get_memory_available(struct soap *soap, struct ns__get_memory_available *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_memory_available(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_memory_availableResponse(struct soap *soap, struct ns__get_memory_availableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->available);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_memory_availableResponse(struct soap *soap, const struct ns__get_memory_availableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_memory_availableResponse(struct soap *soap, const char *tag, int id, const struct ns__get_memory_availableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_memory_availableResponse), type))
		return soap->error;
	if (soap_out_float(soap, "available", -1, &a->available, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_memory_availableResponse * SOAP_FMAC4 soap_in_ns__get_memory_availableResponse(struct soap *soap, const char *tag, struct ns__get_memory_availableResponse *a, const char *type)
{
	size_t soap_flag_available = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_memory_availableResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_memory_availableResponse, sizeof(struct ns__get_memory_availableResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_memory_availableResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_available && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "available", &a->available, "xsd:float"))
				{	soap_flag_available--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_available > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_memory_availableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_memory_availableResponse, SOAP_TYPE_ns__get_memory_availableResponse, sizeof(struct ns__get_memory_availableResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_memory_availableResponse * SOAP_FMAC2 soap_instantiate_ns__get_memory_availableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_memory_availableResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_memory_availableResponse *p;
	size_t k = sizeof(struct ns__get_memory_availableResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_memory_availableResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_memory_availableResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_memory_availableResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_memory_availableResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_memory_availableResponse(struct soap *soap, const struct ns__get_memory_availableResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_memory_availableResponse(soap, tag ? tag : "ns:get-memory-availableResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_memory_availableResponse * SOAP_FMAC4 soap_get_ns__get_memory_availableResponse(struct soap *soap, struct ns__get_memory_availableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_memory_availableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_memory_info(struct soap *soap, struct ns__get_memory_info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_memory_info(struct soap *soap, const struct ns__get_memory_info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_memory_info(struct soap *soap, const char *tag, int id, const struct ns__get_memory_info *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_memory_info), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_memory_info * SOAP_FMAC4 soap_in_ns__get_memory_info(struct soap *soap, const char *tag, struct ns__get_memory_info *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_memory_info*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_memory_info, sizeof(struct ns__get_memory_info), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_memory_info(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_memory_info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_memory_info, SOAP_TYPE_ns__get_memory_info, sizeof(struct ns__get_memory_info), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_memory_info * SOAP_FMAC2 soap_instantiate_ns__get_memory_info(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_memory_info(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_memory_info *p;
	size_t k = sizeof(struct ns__get_memory_info);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_memory_info, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_memory_info);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_memory_info, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_memory_info location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_memory_info(struct soap *soap, const struct ns__get_memory_info *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_memory_info(soap, tag ? tag : "ns:get-memory-info", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_memory_info * SOAP_FMAC4 soap_get_ns__get_memory_info(struct soap *soap, struct ns__get_memory_info *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_memory_info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_memory_infoResponse(struct soap *soap, struct ns__get_memory_infoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->info);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_memory_infoResponse(struct soap *soap, const struct ns__get_memory_infoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->info, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->info);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_memory_infoResponse(struct soap *soap, const char *tag, int id, const struct ns__get_memory_infoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_memory_infoResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "info", -1, &a->info, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_memory_infoResponse * SOAP_FMAC4 soap_in_ns__get_memory_infoResponse(struct soap *soap, const char *tag, struct ns__get_memory_infoResponse *a, const char *type)
{
	size_t soap_flag_info = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_memory_infoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_memory_infoResponse, sizeof(struct ns__get_memory_infoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_memory_infoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "info", &a->info, "xsd:string"))
				{	soap_flag_info--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_info > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_memory_infoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_memory_infoResponse, SOAP_TYPE_ns__get_memory_infoResponse, sizeof(struct ns__get_memory_infoResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_memory_infoResponse * SOAP_FMAC2 soap_instantiate_ns__get_memory_infoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_memory_infoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_memory_infoResponse *p;
	size_t k = sizeof(struct ns__get_memory_infoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_memory_infoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_memory_infoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_memory_infoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_memory_infoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_memory_infoResponse(struct soap *soap, const struct ns__get_memory_infoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_memory_infoResponse(soap, tag ? tag : "ns:get-memory-infoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_memory_infoResponse * SOAP_FMAC4 soap_get_ns__get_memory_infoResponse(struct soap *soap, struct ns__get_memory_infoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_memory_infoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_cpu_usage(struct soap *soap, struct ns__get_cpu_usage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_cpu_usage(struct soap *soap, const struct ns__get_cpu_usage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_cpu_usage(struct soap *soap, const char *tag, int id, const struct ns__get_cpu_usage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_cpu_usage), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_cpu_usage * SOAP_FMAC4 soap_in_ns__get_cpu_usage(struct soap *soap, const char *tag, struct ns__get_cpu_usage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_cpu_usage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_cpu_usage, sizeof(struct ns__get_cpu_usage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_cpu_usage(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_cpu_usage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_cpu_usage, SOAP_TYPE_ns__get_cpu_usage, sizeof(struct ns__get_cpu_usage), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_cpu_usage * SOAP_FMAC2 soap_instantiate_ns__get_cpu_usage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_cpu_usage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_cpu_usage *p;
	size_t k = sizeof(struct ns__get_cpu_usage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_cpu_usage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_cpu_usage);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_cpu_usage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_cpu_usage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_cpu_usage(struct soap *soap, const struct ns__get_cpu_usage *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_cpu_usage(soap, tag ? tag : "ns:get-cpu-usage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_cpu_usage * SOAP_FMAC4 soap_get_ns__get_cpu_usage(struct soap *soap, struct ns__get_cpu_usage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_cpu_usage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_cpu_usageResponse(struct soap *soap, struct ns__get_cpu_usageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_cpu_usageResponse(struct soap *soap, const struct ns__get_cpu_usageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_cpu_usageResponse(struct soap *soap, const char *tag, int id, const struct ns__get_cpu_usageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_cpu_usageResponse), type))
		return soap->error;
	if (soap_out_float(soap, "usage", -1, &a->usage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_cpu_usageResponse * SOAP_FMAC4 soap_in_ns__get_cpu_usageResponse(struct soap *soap, const char *tag, struct ns__get_cpu_usageResponse *a, const char *type)
{
	size_t soap_flag_usage = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_cpu_usageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_cpu_usageResponse, sizeof(struct ns__get_cpu_usageResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_cpu_usageResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_usage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "usage", &a->usage, "xsd:float"))
				{	soap_flag_usage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_usage > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_cpu_usageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_cpu_usageResponse, SOAP_TYPE_ns__get_cpu_usageResponse, sizeof(struct ns__get_cpu_usageResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_cpu_usageResponse * SOAP_FMAC2 soap_instantiate_ns__get_cpu_usageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_cpu_usageResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_cpu_usageResponse *p;
	size_t k = sizeof(struct ns__get_cpu_usageResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_cpu_usageResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_cpu_usageResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_cpu_usageResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_cpu_usageResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_cpu_usageResponse(struct soap *soap, const struct ns__get_cpu_usageResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_cpu_usageResponse(soap, tag ? tag : "ns:get-cpu-usageResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_cpu_usageResponse * SOAP_FMAC4 soap_get_ns__get_cpu_usageResponse(struct soap *soap, struct ns__get_cpu_usageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_cpu_usageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_cpu_info(struct soap *soap, struct ns__get_cpu_info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_cpu_info(struct soap *soap, const struct ns__get_cpu_info *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_cpu_info(struct soap *soap, const char *tag, int id, const struct ns__get_cpu_info *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_cpu_info), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_cpu_info * SOAP_FMAC4 soap_in_ns__get_cpu_info(struct soap *soap, const char *tag, struct ns__get_cpu_info *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_cpu_info*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_cpu_info, sizeof(struct ns__get_cpu_info), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_cpu_info(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_cpu_info *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_cpu_info, SOAP_TYPE_ns__get_cpu_info, sizeof(struct ns__get_cpu_info), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_cpu_info * SOAP_FMAC2 soap_instantiate_ns__get_cpu_info(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_cpu_info(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_cpu_info *p;
	size_t k = sizeof(struct ns__get_cpu_info);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_cpu_info, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_cpu_info);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_cpu_info, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_cpu_info location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_cpu_info(struct soap *soap, const struct ns__get_cpu_info *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_cpu_info(soap, tag ? tag : "ns:get-cpu-info", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_cpu_info * SOAP_FMAC4 soap_get_ns__get_cpu_info(struct soap *soap, struct ns__get_cpu_info *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_cpu_info(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_cpu_infoResponse(struct soap *soap, struct ns__get_cpu_infoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->info);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_cpu_infoResponse(struct soap *soap, const struct ns__get_cpu_infoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->info, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->info);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_cpu_infoResponse(struct soap *soap, const char *tag, int id, const struct ns__get_cpu_infoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_cpu_infoResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "info", -1, &a->info, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_cpu_infoResponse * SOAP_FMAC4 soap_in_ns__get_cpu_infoResponse(struct soap *soap, const char *tag, struct ns__get_cpu_infoResponse *a, const char *type)
{
	size_t soap_flag_info = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns__get_cpu_infoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_cpu_infoResponse, sizeof(struct ns__get_cpu_infoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__get_cpu_infoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_info && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "info", &a->info, "xsd:string"))
				{	soap_flag_info--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_info > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__get_cpu_infoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_cpu_infoResponse, SOAP_TYPE_ns__get_cpu_infoResponse, sizeof(struct ns__get_cpu_infoResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__get_cpu_infoResponse * SOAP_FMAC2 soap_instantiate_ns__get_cpu_infoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_cpu_infoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__get_cpu_infoResponse *p;
	size_t k = sizeof(struct ns__get_cpu_infoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns__get_cpu_infoResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns__get_cpu_infoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns__get_cpu_infoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__get_cpu_infoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_cpu_infoResponse(struct soap *soap, const struct ns__get_cpu_infoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__get_cpu_infoResponse(soap, tag ? tag : "ns:get-cpu-infoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_cpu_infoResponse * SOAP_FMAC4 soap_get_ns__get_cpu_infoResponse(struct soap *soap, struct ns__get_cpu_infoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_cpu_infoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
